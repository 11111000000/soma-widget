* Универсальный SVG Виджет
** Идея

Модульный фронтенд виджета. Структурирован согласно актуальным стандартам  *Веб-компонентов* и *ES-модулей*.  Спроектирован в духе *KISS*, *ФП* и *Elm-архитектуры* Управляется комбинацией *Единого Атома Состояния*, *Однонаправленного Потока Данных* и *Хуков*. Связь с серверной частью организовано посредством кода ORM, генерируемого из спецификации в формате OpenAPI.

** Структура

- Модульная архитектура на базе ES modules, модули декопозированы согласно кейсам использования
- Моно-репозитарий на базе `yarn workspaces`, за счёт чего все зависимости модулей, при их установке, не дублируются в отдельных модулях.

** Инструкция

Для установки зависимостей всех модулей, находясь в корне проекта:

#+begin_src shell
yarn
#+end_src

Для запуска dev-сервера c HMR, находясь в корне проекта:

#+begin_src shell
yarn start
#+end_src

Для сборки:

#+begin_src shell
yarn build
#+end_src

* Модульность и композиция

 /Пишите простые части, соединяемые понятными интерфейсами/
 
 /Пишите программы  так, чтобы их можно было соединить с другими программами/

*** Функциональное программирование

/...Введя присваивание, мы вынуждены внести в свои вычислительные модели понятие времени (time). До того, как появилось присваивание, наши программы от времени не зависели — в том смысле, что всякое выражение, обладающее значением, всегда имело одно и то же значение./
( /SICP/ )

- Функциональная абстракция и композиция вместо ООП (По возможности не используется *class* и *this*)
- Фабрики - вместо классов и наследования
- Константы - вместо переменных (*const* вместо *var*)
- Итераторы (*map* / *reduce*)
- Компоненты - функции от данных, возвращающие HTML

*** Генерация кода

/Избегайте ручного набора кода; при любом удобном случае пишите программы, которые бы писали программы/

Чтобы упростить и ускорить создание новых модулей и сущностей для типовых компонентов и моделей, мы используем генераторы кода из шаблонов, например [[https://github.com/jondot/hygen][hygen]] 

*** Отделение интерфейса от реализации

/Отделяйте правила от механизма; отделяйте интерфейс от движка/

  устройство компонентов интерфейса, как чистых функций от состояния модели. Компоненты интерфейса восновном не содержат деталий бизнес-логики, которая сосредоточена в редьюсерах и хуках или конечном автомате. 

*** Надёжность

/Надёжность — дитя прозрачности и простоты/

*** Оптимизация

  /Сначала — опытный образец, потом — «причесывание». Добейтесь стабильной работы, только потом оптимизируйте/

*** Экономность и простота

  /Простое лучше заумного. Добавляйте сложность, только где необходимо/

*** Web-Компоненты

[[https://codaholic.sillo.org/wp-content/uploads/2020/01/Capture-34.png]]

 *Web-компоненты* — ряд стандартов от консорциума **W3C**, которые направлены на формирование культуры многократно используемых компонентов для веб-приложений. 

 Веб-компоненты поддерживаются современными веб-браузерами напрямую и не требуют дополнительных библиотек для работы, однако при разработке с их использованием нужно придерживаться ряда правил и технологий (см. `customElements.define(...)` и `LitElement`).
 Спецификация включает в себя четыре стандарта, каждый из которых может применяться самостоятельно:

 - **Custom Elements** — расширение нативных и создание собственных HTML-элементов (тегов)
 - **HTML Templates** — тег `<template>` позволяет реализовывать шаблоны для компонентов (используем только `<slot>`)
 - **Shadow DOM** — изолирует DOM и стили (замена iframe для изоляции компонента)
 - **ES Imports** - загрузка модулей, Buldless и CDN

*** Elm-архитектура

[[https://medium.com/javascript-inside/elm-architecture-for-react-951b383fcd65][паттерн компоновки приложения]], представляющий собой бесконечно вкладываемые блоки. Он сильно улучшает модульность, упрощает повторное использование кода и тестирование. 
[[https://sporto.github.io/elm-workshop/images/diagram-tea.png]]

Логика программы разбивается на три чётко разделённые части: модель, обновление и отображение. Можно каждый раз начинать с этого скелета компонента, а затем постепенно заполнять его подробностями под конкретную задачу.

Условная формула интерфейса в Elm-архитектуре (псевдокод):

#+BEGIN_EXAMPLE
render = (state, actions) => return `<button onAction=${actions.someAction}>${state.someState}</button>`

loop((currentState, action) => {
  newState = machine.transition(currentState, action)
  render(newState, actions)
  return newState
})
#+END_EXAMPLE

Применение *Elm-архитектуры* на практике означает, что компоненты интерфейса восновном - [[https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8][чистые функции]] . Например, кнопка с картинкой и надписью:

#+BEGIN_EXAMPLE
import icon from 'modules/art/test.png'

export default component((props) => (
  (state, actions) => {
    return (
      <button onclick={ actions.buttonClick } >
        <span>{ state.flag ? 'Вкл' : 'Выкл' }</span>
      </button>
    )
  }
))
#+END_EXAMPLE

Изменение состояния - также чистая функция, возвращающая новое состояние (reducer):

#+BEGIN_SRC javascript
export const state = {
  flag: false,
  something: [1,2,3]
}

export const actions = {
  buttonClick: () => 
    (state,actions) => 
      ({ ...state, flag: !state.flag })
      
}
#+END_SRC

Переиспользование и расширение моделей управления состоянием достигается [[https://github.com/acdlite/recompose][функциональной композицией]], в противовес /наследованию/

*** Функциональное управление состоянием

 При формировании компонентов мы *НЕ*  используем ООП-классов, не реализуем состояния в `this`.  Состояние хранится и получается  либо посредством хуков - `useState`, или `useReducer`, или `useMachine`, или передаётся через `props` элемента. Это позволяет поддерживать удобный в отладке *однонаправленный поток данных*, т.о. избежав запутанности логики.
 
 Что касается принципа при выборе того или иного механизма управления состоянием, рекомендуется придерживаться следующего алгоритма:
 
  - если состояние элементов компонента не используется в других компонентах, а является локальным для текущего компонента, тогда применяем хуки: *useState* или *useReducer* (когда данные сложнее скалярного типа)
 
  - если изменение состояния влечёт за собой *побочные эффекты*, такие как запросы к серверу, или оно  должно отражаться на состоянии других элементов - нужно использовать хук `useEffect`, `useMachine` для подключения соответствующего автомата, либо обернуть компонент как `observedComponent(MyComponent)` и использовать состояние из модуля `pact-app-state` (см. реализацию `pact-app-screen-auth`)

  - При использовании объекта appState в веб-компоненте, созданном при помощи `observedComponent`, изменения в полях этого объёкта приводят к перерисовке компонента. Т.е. элементарно можно написать:

#+begin_src 
import { html,render,observedComponent } from dna
import { appState } from 'app-state'
                                                 '
customElements.define('user-name-tag', observedComponent(() => html`<div style="color:green">${appState.userName}</div>`))
  
render(window.body html`<user-name-tag></user-name-tag>`)
#+end_src

что напечатает зелёное имя Пользователя


**** Хуки

 Хуки - способ управления состоянием приложения и создания побочных эффектов, используя только функции.  

 Обычно мы создаём класс в React или Web Components, когда необходим некоторый жизненный цикл, состояние или логика:

#+BEGIN_SRC javascript
class {
  constructor(props) {...}
  componentDidMount() {...}
  componentWillUnmount() {...}
  render() {...}
}
#+END_SRC

 Хуки позволяют нам создавать компоненты с состоянием, без использования классов:

#+BEGIN_SRC javascript
function {
  useHook{...};
  useHook{...};
  useHook{...};
  return (
    ...
  );
}
#+END_SRC

Для реализации Hooks API в связке с lit-element, мы используем микро-библиотеку Haunted
  
**** Машина состояний

(вариант: robot)

Для нас это способ повышения продуктивности разработчика, улучшающий, часто шаткие, взаимоотношения c дизайнерами UX, за счёт  детерминированного описания функциональности. Идея конечного автомата очень проста: условно, любой наш компонент может находиться в одном из неких состояний, число которых ограничено, переходы между состояниями происходят при вызове экшенов.

[[https://symfony.com/doc/current/_images/pull_request.png]]

В компоненте верхнего уровня он подключается через хук *useMachine*:

#+BEGIN_SRC javascript
const App = () => {
  const [current, send] = useMachine(searchMachine)
  ...
#+END_SRC

где `current`    - текущее состояние автомата
а `send` - способ отправить событие.

**** Шина

Для универсальной связки различных компонентов и сервисов, мы используем шину данных на базе pubsubjs

- [X] Добавить pubsubjs

